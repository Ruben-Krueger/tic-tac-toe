<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Tic-Tac-Toe</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"/>
    <link rel="stylesheet" href="main.css"/>
</head>
<body>

<div class="container">

    <div class="row">
        <div class="col">
            <h1 class="text-center">Tic-Tac-Toe</h1>
            <h1 class="text-center" id="notification"></h1>
            <canvas id="game" width="400" height="400"></canvas>
        </div>
    </div>
</div>


<script type="text/javascript">

    // TODO: Fix outline bug

    const canvas = document.getElementById("game");
    var ctx = canvas.getContext("2d");

    const ROW_LENGTH = 3;
    const COL_LENGTH = 3;
    const PLAYER_ONE = "X";
    const PLAYER_TWO = "O";
    const WINNING_NUM = 3;


    const VERTICAL_OFFSET = 20;
    const FONT = "60px Arial";

    const SQUARE_SIZE = 100;

    class Square {

        constructor(r, c) {
            this.width = 100;
            this.height = 100;
            this.x = r * SQUARE_SIZE;
            this.y = c * SQUARE_SIZE;
            this.player = "";
        }

        render() {
            ctx.rect(this.x, this.y, this.width, this.height);
            ctx.strokeStyle="white";
            ctx.lineWidth="6";
            ctx.stroke();
        }

        drawPlayer(player) {
            ctx.font = FONT;
            ctx.strokeText(player, this.x + SQUARE_SIZE / 4, this.y +SQUARE_SIZE / 2 + VERTICAL_OFFSET);
            this.player = player;
        }

    }

    class Board {

        constructor() {
            this.squares = [[]];

            for(let i = 0; i < ROW_LENGTH; i ++) {

                // Because of Javascript memory bug
                this.squares.push([]);

                for(let j = 0; j < COL_LENGTH; j ++) {
                    this.squares[i][j] = new Square(i,j);
                }
            }

            canvas.addEventListener("click", this.update);
        }

        update(e) {
            const rect = canvas.getBoundingClientRect();
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;

            const row = Math.floor(canvasX / SQUARE_SIZE);
            const col = Math.floor(canvasY / SQUARE_SIZE);

            if(game.board.squares[row][col].player !== "" || game.gameOver) return;

            game.board.squares[row][col].drawPlayer(game.currentPlayer);

            Board.checkWinner();

            // switch who's turn it is next
            game.currentPlayer = game.currentPlayer === PLAYER_ONE ? PLAYER_TWO : PLAYER_ONE;

            game.notify();

        }

        render() {
            for(let i = 0; i < ROW_LENGTH; i ++) {
               for(let j = 0; j < COL_LENGTH; j ++) {
                   this.squares[i][j].render();
               }
            }
        }


        static checkWinner() {
            console.log('checking winner');
            const winningCombos = [
                [[0,0], [0,1], [0,2]],
                [[1,0], [1,1], [1,2]],
                [[2,0], [2,1], [2,2]],
                [[0,0], [1,0], [2,0]],
                [[0,1], [1,1], [1,2]],
                [[0,2], [1,2], [2,2]],

                [[0,0], [1,1], [2,2]],
                [[0,2], [1,1], [2,0]],

            ];

            for(let i = 0; i < winningCombos.length; i++) {
                var inRow = 0;

                for(let j = 0; j < winningCombos[i].length; j++) {
                    const row = winningCombos[i][j][0];
                    const col = winningCombos[i][j][1];

                    if(game.board.squares[row][col].player === game.currentPlayer) {
                        inRow++;
                    }

                    if(inRow === WINNING_NUM) {
                        console.log('three in a row');
                        Game.win();
                    }
                }

            }

        }
    }

    class Game {


        constructor() {
            this.board = new Board();
            this.currentPlayer = PLAYER_ONE;
            this.gameOver = false;
        }

        notify() {

            if(this.gameOver) {

            }
            else {
                document.getElementById('notification').innerText = `It is ${game.currentPlayer}'s turn`;
            }
        }

        render() {
            this.board.render();
        }

        reset() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            this.board = new Board();
        }

        static win() {
            console.log('winning');
            game.gameOver = true;
            document.getElementById('notification').innerText = `Player ${game.currentPlayer} won!`;
        }

    }

    game = new Game();


    setInterval(game.render(), 100);


</script>


</body>
</html>
